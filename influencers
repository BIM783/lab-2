import random, math
import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection
import time

random.seed(int(time.time()))

def er_graph(n, p):
    adj = [[] for _ in range(n)]
    for i in range(n):
        for j in range(i+1, n):
            if random.random() < p:
                adj[i].append(j); adj[j].append(i)
    return adj

def circle_layout(n):
    return [(math.cos(2*math.pi*k/n), math.sin(2*math.pi*k/n)) for k in range(n)]

def degroot_step(x, adj, alpha, influencers):
    x_next = []
    for i in range(len(x)):
        # Если агент - инфлюенсер, его мнение не меняется
        if i in influencers:
            x_next.append(x[i])
            continue
            
        if len(adj[i]) == 0:
            x_next.append(x[i])
            continue
            
        avg = sum(x[j] for j in adj[i]) / len(adj[i])
        x_next.append(alpha*x[i] + (1-alpha)*avg)
    return x_next

def draw_graph(pos, adj, values, ax, title="", influencers=None):
    ax.clear()
    segs = [[pos[i], pos[j]] for i in range(len(adj)) for j in adj[i] if j>i ]
    ax.add_collection(LineCollection(segs, colors="lightgray", linewidths=0.8))
    xs, ys = zip(*pos)
    
    # Разделяем обычных агентов и инфлюенсеров для разного оформления
    if influencers is None:
        influencers = set()
    
    normal_indices = [i for i in range(len(pos)) if i not in influencers]
    influencer_indices = list(influencers)
    
    # Рисуем обычных агентов
    if normal_indices:
        normal_xs = [xs[i] for i in normal_indices]
        normal_ys = [ys[i] for i in normal_indices]
        normal_values = [values[i] for i in normal_indices]
        ax.scatter(normal_xs, normal_ys, c=normal_values, vmin=0, vmax=1, 
                  cmap="viridis", s=100, edgecolors="k")
    
    # Рисуем инфлюенсеров с другим стилем
    if influencer_indices:
        influencer_xs = [xs[i] for i in influencer_indices]
        influencer_ys = [ys[i] for i in influencer_indices]
        influencer_values = [values[i] for i in influencer_indices]
        ax.scatter(influencer_xs, influencer_ys, c=influencer_values, vmin=0, vmax=1, 
                  cmap="viridis", s=150, edgecolors="red", linewidths=2, marker="s")
    
    ax.set_title(title); ax.set_aspect("equal"); ax.axis("off")
    
    # Создаем scatter plot для цветовой шкалы
    sc = ax.scatter(xs, ys, c=values, vmin=0, vmax=1, cmap="viridis", s=0)
    return sc

N = 40
p = 0.07
T = 20
alpha = 0.5

# Создаем инфлюенсеров (5% от общего числа агентов)
num_influencers = max(1, int(N * 0.05))  # минимум 1 инфлюенсер
influencers = set(random.sample(range(N), num_influencers))

print(f"Инфлюенсеры (неизменяемое мнение): {influencers}")

adj = er_graph(N, p)
pos = circle_layout(N)
x = [random.random() for _ in range(N)]

plt.ion()
fig, ax = plt.subplots(figsize=(6,6))
sc = draw_graph(pos, adj, x, ax, "t=0", influencers)
plt.colorbar(sc, ax=ax)

for t in range(1, T+1):
    x = degroot_step(x, adj, alpha, influencers)
    sc.set_array(x)
    ax.set_title(f"t={t}")
    # Перерисовываем граф с обновленными позициями инфлюенсеров
    sc = draw_graph(pos, adj, x, ax, f"t={t}", influencers)
    plt.pause(0.2)

plt.ioff(); plt.show()

# Выводим финальные мнения
print("\nФинальные мнения:")
for i in range(N):
    status = " (инфлюенсер)" if i in influencers else ""
    print(f"Агент {i}: {x[i]:.3f}{status}")
